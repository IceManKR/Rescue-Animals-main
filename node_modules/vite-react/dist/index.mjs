// src/index.ts
import * as vite from "vite";
import { loadConfigFromFile, loadEnv, mergeConfig } from "vite";

// src/vite.ts
import { defineConfig as origin } from "vite";

// src/handler/build.ts
import { extname } from "path";
var assetPatterns = [
  ["media", /\.(mp4|webm|ogg|mp3|wav|flac|aac|swf)(\?.*)?$/i],
  ["image", /\.(png|jpe?g|gif|ico|svg|webp)(\?.*)?$/i],
  ["font", /\.(woff2?|eot|ttf|otf)(\?.*)?$/i],
  ["style", /\.(s?css|less|styl)(\?.*)?$/i]
];
var handleBuild = (config, _env) => {
  config.build ||= {};
  config.build.reportCompressedSize ??= false;
  config.build.rollupOptions ||= {};
  config.build.rollupOptions.output ||= {};
  const keys = Object.keys(config.build.rollupOptions.output);
  const overrideKeys = [
    "assetFileNames",
    "chunkFileNames",
    "entryFileNames"
  ];
  const userDefined = keys.some((key) => overrideKeys.includes(key));
  if (!userDefined) {
    config.build.rollupOptions.output = {
      ...config.build.rollupOptions.output,
      assetFileNames(assetInfo) {
        const ext = extname(assetInfo.name || "");
        let folder = "misc";
        for (const [name, pattern] of assetPatterns) {
          if (pattern.test(ext)) {
            folder = name;
            break;
          }
        }
        return `bundle/${folder}/[name]-[hash][extname]`;
      },
      chunkFileNames: "bundle/js/[name]-[hash].js",
      entryFileNames: "bundle/js/[name]-[hash].js"
    };
  }
};

// src/handler/css.ts
var handleCss = (config, env) => {
  config.css ||= {};
  config.css.modules ||= {};
  if (config.css.modules !== false) {
    config.css.modules.generateScopedName ??= env.command === "build" ? "[hash:base64]" : "[path][name]__[local]";
  }
};

// src/handler/html.ts
import { createHtmlPlugin } from "vite-plugin-html";
var handleHtml = (config, env) => {
  const html = config.html;
  if (!html) {
    return;
  }
  let minify = html.minify;
  if (minify === void 0) {
    minify = env.command === "build";
  }
  config.plugins ||= [];
  config.plugins.push(createHtmlPlugin({
    minify,
    inject: {
      data: html.injectData,
      tags: html.injectTags
    },
    template: html.template
  }));
};

// src/handler/legacy.ts
import legacy from "@vitejs/plugin-legacy";

// src/util/override.ts
var override = (fn, env, options) => {
  if (typeof fn === "object") {
    return fn;
  }
  if (typeof fn === "function") {
    const result = fn(options, env);
    return result === void 0 ? options : result;
  }
  return options;
};

// src/util/enable.ts
var enable = (fn, env, defaultEnalbe) => {
  if (typeof fn === "function") {
    return fn(env);
  }
  if (typeof fn === "boolean") {
    return fn;
  }
  if (typeof defaultEnalbe === "function") {
    return defaultEnalbe(env);
  }
  return defaultEnalbe;
};

// src/handler/legacy.ts
var handleLegacy = (config, env) => {
  var _a, _b;
  config.plugins ||= [];
  if (enable((_a = config.legacy) == null ? void 0 : _a.enable, env, false)) {
    config.plugins.push(legacy(override((_b = config.legacy) == null ? void 0 : _b.options, env, {})));
  }
};

// src/handler/mix.ts
var handleMix = (config, _env) => {
  config.base ??= "./";
  config.clearScreen ??= false;
};

// src/handler/react.ts
import react from "@vitejs/plugin-react";
var handleReact = (config, env) => {
  config.plugins ||= [];
  config.plugins.push(react(override(config.react, env, {})));
};

// src/handler/server.ts
var handleServer = (config, _env) => {
  config.server ||= {};
  config.server.open ??= true;
};

// src/handler/styleImport.ts
import {
  createStyleImportPlugin
} from "vite-plugin-style-import";
import { AntdResolve } from "vite-plugin-style-import";
var styleResolves = {
  antd: AntdResolve
};
var handleStyleImport = (config, env) => {
  var _a, _b;
  config.plugins ||= [];
  if (enable((_a = config.styleImport) == null ? void 0 : _a.enable, env, true)) {
    config.plugins.push(createStyleImportPlugin(override((_b = config.styleImport) == null ? void 0 : _b.options, env, {})));
  }
};

// src/vite.ts
var defineConfig = (config = {}) => {
  return origin((env) => {
    return parseConfig(typeof config === "function" ? config(env) : config, env);
  });
};
var parseConfig = (config, env) => {
  handleReact(config, env);
  handleLegacy(config, env);
  handleCss(config, env);
  handleStyleImport(config, env);
  handleBuild(config, env);
  handleMix(config, env);
  handleServer(config, env);
  handleHtml(config, env);
  return config;
};
export {
  defineConfig,
  loadConfigFromFile,
  loadEnv,
  mergeConfig,
  styleResolves,
  vite
};
//# sourceMappingURL=index.mjs.map